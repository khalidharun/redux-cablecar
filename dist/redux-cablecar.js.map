{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap caecf92c08eab3fac4d2","webpack:///./src/index.js","webpack:///./src/actions.js","webpack:///./src/middleware.js","webpack:///./src/cableCar.js","webpack:///./~/actioncable/lib/assets/compiled/action_cable.js"],"names":["cableConnect","cableDisconnect","cableSubscribe","cableUnsubscribe","cableSend","url","type","cable","channel","params","payload","car","middleware","action","store","subscribe","unsubscribe","disconnect","send","newState","next","connect","CableCar","startDebugging","consumer","createConsumer","dispatch","options","prefix","toUpperCase","subscription","subscriptions","create","initialized","connected","disconnected","received","data","rejected","Error","JSON","stringify","identifier","findAll","map","item","x"],"mappings":"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CAAWY,QAAX,CAAoB,EAAEpB,MAAM,oBAAR,EAApB;AACD;;;;;;mBAGYgB,Q;;;;;;ACvDf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;AACL,IAAG;;AAEH;;AAEA;AACA;AACA,mCAAkC,mBAAmB,gCAAgC,GAAG;;AAExF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,QAAO;;AAEP,MAAK;AACL;AACA;AACA;AACA,iCAAgC,mBAAmB,gCAAgC,GAAG,EAAE;AACxF,iDAAgD,iCAAiC,OAAO,OAAO,6CAA6C,EAAE,WAAW;;AAEzJ;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX;AACA;AACA;AACA;;AAEA;;AAEA,QAAO;;AAEP,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,kDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;;AAEA,QAAO;;AAEP,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAO;;AAEP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAO;;AAEP,MAAK;AACL,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA;AACA,EAAC","file":"redux-cablecar.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"redux-cablecar\"] = factory();\n\telse\n\t\troot[\"redux-cablecar\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap caecf92c08eab3fac4d2","export * from './actions';\nexport * from './middleware';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","export function cableConnect(url) {\n  return {\n    type: 'CABLE_CONNECT',\n    cable: { url }\n  };\n}\n\nexport function cableDisconnect() {\n  return {\n    type: 'CABLE_DISCONNECT',\n    cable: {}\n  };\n}\n\nexport function cableSubscribe(channel, params) {\n  return {\n    type: 'CABLE_SUBSCRIBE',\n    cable: { channel, params }\n  };\n}\n\nexport function cableUnsubscribe(channel, params) {\n  return {\n    type: 'CABLE_UNSUBSCRIBE',\n    cable: { channel, params }\n  };\n}\n\nexport function cableSend(channel, params, payload) {\n  return {\n    type: 'CABLE_SEND',\n    cable: { channel, params },\n    payload\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions.js","import CableCar from './cableCar';\n\nlet car;\n\nconst middleware = store => next => (action) => {\n\n  switch (action.type) {\n    case 'CABLE_CONNECT':\n      const { url } = action.cable;\n      new CableCar(url, store);\n      break;\n    case 'CABLE_SUBSCRIBE':\n      car.subscribe(action.cable.channel, action.cable.params);\n      break;\n    case 'CABLE_UNSUBSCRIBE':\n      car.unsubscribe(action.cable.channel, action.cable.params);\n      break;\n    case 'CABLE_DISCONNECT':\n      car.disconnect();\n      car = null;\n      break;\n    case 'CABLE_SEND':\n      car.send(action.cable.channel, action.cable.params, action.payload);\n    default:\n      break;\n  }\n\n  const newState = next(action);\n\n  switch (action.type) {\n    case 'CABLE_CONNECTED':\n      car = action.cable.car;\n      break;\n    default:\n      break;\n  }\n\n  return newState;\n};\n\nmiddleware.connect = (url, store) => new CableCar(url, store);\n\nexport { middleware };\n\n\n\n// WEBPACK FOOTER //\n// ./src/middleware.js","import ActionCable from 'actioncable';\n\nclass CableCar {\n\n  constructor(url, store) {\n    this.store = store;\n    ActionCable.startDebugging();\n    this.consumer = ActionCable.createConsumer(url);\n    this.store.dispatch({ type: 'CABLE_CONNECTED', cable: { car: this } });\n  }\n\n  dispatch(type, cable, payload = {}) {\n    const action = {\n      type: `CABLE_${type}`,\n      cable,\n      payload,\n    };\n    this.store.dispatch(action);\n  }\n\n  subscribe(channel, params) {\n    const options = { channel , ...params};\n    const prefix = channel.toUpperCase();\n    this.subscription = this.consumer.subscriptions.create(options, {\n      initialized:  () => this.dispatch(`${prefix}_INITIALIZED`, options),\n      connected:    () => this.dispatch(`${prefix}_CONNECTED`, options),\n      disconnected: () => this.dispatch(`${prefix}_DISCONNECTED`, options),\n      received: (data) => this.dispatch(`${prefix}_RECEIVED`, options, data),\n      rejected:     () => {\n        this.dispatch(`${prefix}_REJECTED`, options);\n        throw new Error(`ActionCable: Attempt to subscribe was rejected. (${JSON.stringify(options)})`);\n      }\n    });\n  }\n\n  send(channel, params, payload) {\n    const options = { channel, ...params };\n    const identifier = JSON.stringify(options);\n    const subscriptions = this.consumer.subscriptions.findAll(identifier);\n    subscriptions.map(item => item.send(payload));\n  }\n\n  unsubscribe(channel, params) {\n    const options = { channel, ...params };\n    const identifier = JSON.stringify(options);\n    const subscriptions = this.consumer.subscriptions.findAll(identifier);\n    subscriptions.map( x => x.unsubscribe());\n  }\n\n  disconnect() {\n    this.consumer.disconnect();\n    this.store.dispatch({ type: 'CABLE_DISCONNECTED' });\n  }\n}\n\nexport default CableCar;\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCar.js","(function() {\n  (function() {\n    (function() {\n      var slice = [].slice;\n\n      this.ActionCable = {\n        INTERNAL: {\n          \"message_types\": {\n            \"welcome\": \"welcome\",\n            \"ping\": \"ping\",\n            \"confirmation\": \"confirm_subscription\",\n            \"rejection\": \"reject_subscription\"\n          },\n          \"default_mount_path\": \"/cable\",\n          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n        },\n        createConsumer: function(url) {\n          var ref;\n          if (url == null) {\n            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n          }\n          return new ActionCable.Consumer(this.createWebSocketURL(url));\n        },\n        getConfig: function(name) {\n          var element;\n          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n          return element != null ? element.getAttribute(\"content\") : void 0;\n        },\n        createWebSocketURL: function(url) {\n          var a;\n          if (url && !/^wss?:/i.test(url)) {\n            a = document.createElement(\"a\");\n            a.href = url;\n            a.href = a.href;\n            a.protocol = a.protocol.replace(\"http\", \"ws\");\n            return a.href;\n          } else {\n            return url;\n          }\n        },\n        startDebugging: function() {\n          return this.debugging = true;\n        },\n        stopDebugging: function() {\n          return this.debugging = null;\n        },\n        log: function() {\n          var messages;\n          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this.debugging) {\n            messages.push(Date.now());\n            return console.log.apply(console, [\"[ActionCable]\"].concat(slice.call(messages)));\n          }\n        }\n      };\n\n    }).call(this);\n  }).call(this);\n\n  var ActionCable = this.ActionCable;\n\n  (function() {\n    (function() {\n      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n      ActionCable.ConnectionMonitor = (function() {\n        var clamp, now, secondsSince;\n\n        ConnectionMonitor.pollInterval = {\n          min: 3,\n          max: 30\n        };\n\n        ConnectionMonitor.staleThreshold = 6;\n\n        function ConnectionMonitor(connection) {\n          this.connection = connection;\n          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n          this.reconnectAttempts = 0;\n        }\n\n        ConnectionMonitor.prototype.start = function() {\n          if (!this.isRunning()) {\n            this.startedAt = now();\n            delete this.stoppedAt;\n            this.startPolling();\n            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n          }\n        };\n\n        ConnectionMonitor.prototype.stop = function() {\n          if (this.isRunning()) {\n            this.stoppedAt = now();\n            this.stopPolling();\n            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor stopped\");\n          }\n        };\n\n        ConnectionMonitor.prototype.isRunning = function() {\n          return (this.startedAt != null) && (this.stoppedAt == null);\n        };\n\n        ConnectionMonitor.prototype.recordPing = function() {\n          return this.pingedAt = now();\n        };\n\n        ConnectionMonitor.prototype.recordConnect = function() {\n          this.reconnectAttempts = 0;\n          this.recordPing();\n          delete this.disconnectedAt;\n          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n        };\n\n        ConnectionMonitor.prototype.recordDisconnect = function() {\n          this.disconnectedAt = now();\n          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n        };\n\n        ConnectionMonitor.prototype.startPolling = function() {\n          this.stopPolling();\n          return this.poll();\n        };\n\n        ConnectionMonitor.prototype.stopPolling = function() {\n          return clearTimeout(this.pollTimeout);\n        };\n\n        ConnectionMonitor.prototype.poll = function() {\n          return this.pollTimeout = setTimeout((function(_this) {\n            return function() {\n              _this.reconnectIfStale();\n              return _this.poll();\n            };\n          })(this), this.getPollInterval());\n        };\n\n        ConnectionMonitor.prototype.getPollInterval = function() {\n          var interval, max, min, ref;\n          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n          interval = 5 * Math.log(this.reconnectAttempts + 1);\n          return Math.round(clamp(interval, min, max) * 1000);\n        };\n\n        ConnectionMonitor.prototype.reconnectIfStale = function() {\n          if (this.connectionIsStale()) {\n            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n            this.reconnectAttempts++;\n            if (this.disconnectedRecently()) {\n              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n            } else {\n              ActionCable.log(\"ConnectionMonitor reopening\");\n              return this.connection.reopen();\n            }\n          }\n        };\n\n        ConnectionMonitor.prototype.connectionIsStale = function() {\n          var ref;\n          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.disconnectedRecently = function() {\n          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.visibilityDidChange = function() {\n          if (document.visibilityState === \"visible\") {\n            return setTimeout((function(_this) {\n              return function() {\n                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n                  return _this.connection.reopen();\n                }\n              };\n            })(this), 200);\n          }\n        };\n\n        now = function() {\n          return new Date().getTime();\n        };\n\n        secondsSince = function(time) {\n          return (now() - time) / 1000;\n        };\n\n        clamp = function(number, min, max) {\n          return Math.max(min, Math.min(max, number));\n        };\n\n        return ConnectionMonitor;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n        slice = [].slice,\n        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\n      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\n      ActionCable.Connection = (function() {\n        Connection.reopenDelay = 500;\n\n        function Connection(consumer) {\n          this.consumer = consumer;\n          this.open = bind(this.open, this);\n          this.subscriptions = this.consumer.subscriptions;\n          this.monitor = new ActionCable.ConnectionMonitor(this);\n          this.disconnected = true;\n        }\n\n        Connection.prototype.send = function(data) {\n          if (this.isOpen()) {\n            this.webSocket.send(JSON.stringify(data));\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        Connection.prototype.open = function() {\n          if (this.isActive()) {\n            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n            throw new Error(\"Existing connection must be closed before opening\");\n          } else {\n            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n            if (this.webSocket != null) {\n              this.uninstallEventHandlers();\n            }\n            this.webSocket = new WebSocket(this.consumer.url, protocols);\n            this.installEventHandlers();\n            this.monitor.start();\n            return true;\n          }\n        };\n\n        Connection.prototype.close = function(arg) {\n          var allowReconnect, ref1;\n          allowReconnect = (arg != null ? arg : {\n            allowReconnect: true\n          }).allowReconnect;\n          if (!allowReconnect) {\n            this.monitor.stop();\n          }\n          if (this.isActive()) {\n            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n          }\n        };\n\n        Connection.prototype.reopen = function() {\n          var error, error1;\n          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n          if (this.isActive()) {\n            try {\n              return this.close();\n            } catch (error1) {\n              error = error1;\n              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n            } finally {\n              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n              setTimeout(this.open, this.constructor.reopenDelay);\n            }\n          } else {\n            return this.open();\n          }\n        };\n\n        Connection.prototype.getProtocol = function() {\n          var ref1;\n          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n        };\n\n        Connection.prototype.isOpen = function() {\n          return this.isState(\"open\");\n        };\n\n        Connection.prototype.isActive = function() {\n          return this.isState(\"open\", \"connecting\");\n        };\n\n        Connection.prototype.isProtocolSupported = function() {\n          var ref1;\n          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n        };\n\n        Connection.prototype.isState = function() {\n          var ref1, states;\n          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n        };\n\n        Connection.prototype.getState = function() {\n          var ref1, state, value;\n          for (state in WebSocket) {\n            value = WebSocket[state];\n            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n              return state.toLowerCase();\n            }\n          }\n          return null;\n        };\n\n        Connection.prototype.installEventHandlers = function() {\n          var eventName, handler;\n          for (eventName in this.events) {\n            handler = this.events[eventName].bind(this);\n            this.webSocket[\"on\" + eventName] = handler;\n          }\n        };\n\n        Connection.prototype.uninstallEventHandlers = function() {\n          var eventName;\n          for (eventName in this.events) {\n            this.webSocket[\"on\" + eventName] = function() {};\n          }\n        };\n\n        Connection.prototype.events = {\n          message: function(event) {\n            var identifier, message, ref1, type;\n            if (!this.isProtocolSupported()) {\n              return;\n            }\n            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n            switch (type) {\n              case message_types.welcome:\n                this.monitor.recordConnect();\n                return this.subscriptions.reload();\n              case message_types.ping:\n                return this.monitor.recordPing();\n              case message_types.confirmation:\n                return this.subscriptions.notify(identifier, \"connected\");\n              case message_types.rejection:\n                return this.subscriptions.reject(identifier);\n              default:\n                return this.subscriptions.notify(identifier, \"received\", message);\n            }\n          },\n          open: function() {\n            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n            this.disconnected = false;\n            if (!this.isProtocolSupported()) {\n              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n              return this.close({\n                allowReconnect: false\n              });\n            }\n          },\n          close: function(event) {\n            ActionCable.log(\"WebSocket onclose event\");\n            if (this.disconnected) {\n              return;\n            }\n            this.disconnected = true;\n            this.monitor.recordDisconnect();\n            return this.subscriptions.notifyAll(\"disconnected\", {\n              willAttemptReconnect: this.monitor.isRunning()\n            });\n          },\n          error: function() {\n            return ActionCable.log(\"WebSocket onerror event\");\n          }\n        };\n\n        return Connection;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var slice = [].slice;\n\n      ActionCable.Subscriptions = (function() {\n        function Subscriptions(consumer) {\n          this.consumer = consumer;\n          this.subscriptions = [];\n        }\n\n        Subscriptions.prototype.create = function(channelName, mixin) {\n          var channel, params, subscription;\n          channel = channelName;\n          params = typeof channel === \"object\" ? channel : {\n            channel: channel\n          };\n          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n          return this.add(subscription);\n        };\n\n        Subscriptions.prototype.add = function(subscription) {\n          this.subscriptions.push(subscription);\n          this.consumer.ensureActiveConnection();\n          this.notify(subscription, \"initialized\");\n          this.sendCommand(subscription, \"subscribe\");\n          return subscription;\n        };\n\n        Subscriptions.prototype.remove = function(subscription) {\n          this.forget(subscription);\n          if (!this.findAll(subscription.identifier).length) {\n            this.sendCommand(subscription, \"unsubscribe\");\n          }\n          return subscription;\n        };\n\n        Subscriptions.prototype.reject = function(identifier) {\n          var i, len, ref, results, subscription;\n          ref = this.findAll(identifier);\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            this.forget(subscription);\n            this.notify(subscription, \"rejected\");\n            results.push(subscription);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.forget = function(subscription) {\n          var s;\n          this.subscriptions = (function() {\n            var i, len, ref, results;\n            ref = this.subscriptions;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              s = ref[i];\n              if (s !== subscription) {\n                results.push(s);\n              }\n            }\n            return results;\n          }).call(this);\n          return subscription;\n        };\n\n        Subscriptions.prototype.findAll = function(identifier) {\n          var i, len, ref, results, s;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            s = ref[i];\n            if (s.identifier === identifier) {\n              results.push(s);\n            }\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.reload = function() {\n          var i, len, ref, results, subscription;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.sendCommand(subscription, \"subscribe\"));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notifyAll = function() {\n          var args, callbackName, i, len, ref, results, subscription;\n          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notify = function() {\n          var args, callbackName, i, len, results, subscription, subscriptions;\n          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n          if (typeof subscription === \"string\") {\n            subscriptions = this.findAll(subscription);\n          } else {\n            subscriptions = [subscription];\n          }\n          results = [];\n          for (i = 0, len = subscriptions.length; i < len; i++) {\n            subscription = subscriptions[i];\n            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.sendCommand = function(subscription, command) {\n          var identifier;\n          identifier = subscription.identifier;\n          return this.consumer.send({\n            command: command,\n            identifier: identifier\n          });\n        };\n\n        return Subscriptions;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Subscription = (function() {\n        var extend;\n\n        function Subscription(consumer, params, mixin) {\n          this.consumer = consumer;\n          if (params == null) {\n            params = {};\n          }\n          this.identifier = JSON.stringify(params);\n          extend(this, mixin);\n        }\n\n        Subscription.prototype.perform = function(action, data) {\n          if (data == null) {\n            data = {};\n          }\n          data.action = action;\n          return this.send(data);\n        };\n\n        Subscription.prototype.send = function(data) {\n          return this.consumer.send({\n            command: \"message\",\n            identifier: this.identifier,\n            data: JSON.stringify(data)\n          });\n        };\n\n        Subscription.prototype.unsubscribe = function() {\n          return this.consumer.subscriptions.remove(this);\n        };\n\n        extend = function(object, properties) {\n          var key, value;\n          if (properties != null) {\n            for (key in properties) {\n              value = properties[key];\n              object[key] = value;\n            }\n          }\n          return object;\n        };\n\n        return Subscription;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Consumer = (function() {\n        function Consumer(url) {\n          this.url = url;\n          this.subscriptions = new ActionCable.Subscriptions(this);\n          this.connection = new ActionCable.Connection(this);\n        }\n\n        Consumer.prototype.send = function(data) {\n          return this.connection.send(data);\n        };\n\n        Consumer.prototype.connect = function() {\n          return this.connection.open();\n        };\n\n        Consumer.prototype.disconnect = function() {\n          return this.connection.close({\n            allowReconnect: false\n          });\n        };\n\n        Consumer.prototype.ensureActiveConnection = function() {\n          if (!this.connection.isActive()) {\n            return this.connection.open();\n          }\n        };\n\n        return Consumer;\n\n      })();\n\n    }).call(this);\n  }).call(this);\n\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = ActionCable;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(ActionCable);\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/actioncable/lib/assets/compiled/action_cable.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}