{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///redux-cablecar.min.js","webpack:///webpack/bootstrap e279517a6187629f3f44","webpack:///./src/index.js","webpack:///./src/actions.js","webpack:///./src/middleware.js","webpack:///./src/cableCar.js","webpack:///./~/actioncable/lib/assets/compiled/action_cable.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","defineProperty","value","_actions","keys","forEach","key","enumerable","get","_middleware","cableConnect","url","type","cable","cableDisconnect","cableSubscribe","channel","params","cableUnsubscribe","cableSend","payload","_interopRequireDefault","obj","__esModule","default","middleware","undefined","_cableCar","_cableCar2","car","store","next","action","subscribe","unsubscribe","disconnect","send","newState","connect","_classCallCheck","instance","Constructor","TypeError","_extends","assign","target","i","arguments","length","source","prototype","hasOwnProperty","_createClass","defineProperties","props","descriptor","configurable","writable","protoProps","staticProps","_actioncable","_actioncable2","CableCar","startDebugging","consumer","createConsumer","dispatch","_this","options","prefix","toUpperCase","subscription","subscriptions","create","initialized","connected","disconnected","received","data","rejected","Error","JSON","stringify","identifier","findAll","map","item","x","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","slice","ActionCable","INTERNAL","message_types","welcome","ping","confirmation","rejection","default_mount_path","protocols","ref","getConfig","Consumer","createWebSocketURL","name","element","document","head","querySelector","getAttribute","a","test","createElement","href","protocol","replace","debugging","stopDebugging","log","messages","push","Date","now","console","apply","concat","bind","fn","me","ConnectionMonitor","connection","visibilityDidChange","reconnectAttempts","clamp","secondsSince","pollInterval","min","max","staleThreshold","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","getPollInterval","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","interval","constructor","Math","round","connectionIsStale","disconnectedRecently","reopen","visibilityState","isOpen","getTime","time","number","supportedProtocols","unsupportedProtocol","indexOf","l","Connection","open","monitor","reopenDelay","webSocket","isActive","getState","uninstallEventHandlers","WebSocket","installEventHandlers","close","arg","allowReconnect","ref1","error","error1","getProtocol","isState","isProtocolSupported","states","state","readyState","toLowerCase","eventName","handler","events","message","event","parse","reload","notify","reject","notifyAll","willAttemptReconnect","Subscriptions","channelName","mixin","Subscription","add","ensureActiveConnection","sendCommand","remove","forget","len","results","s","args","callbackName","command","extend","perform","object","properties"],"mappings":"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","file":"redux-cablecar.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"redux-cablecar\"] = factory();\n\telse\n\t\troot[\"redux-cablecar\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"redux-cablecar\"] = factory();\n\telse\n\t\troot[\"redux-cablecar\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _actions = __webpack_require__(1);\n\t\n\tObject.keys(_actions).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _actions[key];\n\t    }\n\t  });\n\t});\n\t\n\tvar _middleware = __webpack_require__(2);\n\t\n\tObject.keys(_middleware).forEach(function (key) {\n\t  if (key === \"default\" || key === \"__esModule\") return;\n\t  Object.defineProperty(exports, key, {\n\t    enumerable: true,\n\t    get: function get() {\n\t      return _middleware[key];\n\t    }\n\t  });\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.cableConnect = cableConnect;\n\texports.cableDisconnect = cableDisconnect;\n\texports.cableSubscribe = cableSubscribe;\n\texports.cableUnsubscribe = cableUnsubscribe;\n\texports.cableSend = cableSend;\n\tfunction cableConnect(url) {\n\t  return {\n\t    type: 'CABLE_CONNECT',\n\t    cable: { url: url }\n\t  };\n\t}\n\t\n\tfunction cableDisconnect() {\n\t  return {\n\t    type: 'CABLE_DISCONNECT',\n\t    cable: {}\n\t  };\n\t}\n\t\n\tfunction cableSubscribe(channel, params) {\n\t  return {\n\t    type: 'CABLE_SUBSCRIBE',\n\t    cable: { channel: channel, params: params }\n\t  };\n\t}\n\t\n\tfunction cableUnsubscribe(channel, params) {\n\t  return {\n\t    type: 'CABLE_UNSUBSCRIBE',\n\t    cable: { channel: channel, params: params }\n\t  };\n\t}\n\t\n\tfunction cableSend(channel, params, payload) {\n\t  return {\n\t    type: 'CABLE_SEND',\n\t    cable: { channel: channel, params: params },\n\t    payload: payload\n\t  };\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.middleware = undefined;\n\t\n\tvar _cableCar = __webpack_require__(3);\n\t\n\tvar _cableCar2 = _interopRequireDefault(_cableCar);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar car = void 0;\n\t\n\tvar middleware = function middleware(store) {\n\t  return function (next) {\n\t    return function (action) {\n\t\n\t      switch (action.type) {\n\t        case 'CABLE_CONNECT':\n\t          var url = action.cable.url;\n\t\n\t          new _cableCar2.default(url, store);\n\t          break;\n\t        case 'CABLE_SUBSCRIBE':\n\t          car.subscribe(action.cable.channel, action.cable.params);\n\t          break;\n\t        case 'CABLE_UNSUBSCRIBE':\n\t          car.unsubscribe(action.cable.channel, action.cable.params);\n\t          break;\n\t        case 'CABLE_DISCONNECT':\n\t          car.disconnect();\n\t          car = null;\n\t          break;\n\t        case 'CABLE_SEND':\n\t          car.send(action.cable.channel, action.cable.params, action.payload);\n\t        default:\n\t          break;\n\t      }\n\t\n\t      var newState = next(action);\n\t\n\t      switch (action.type) {\n\t        case 'CABLE_CONNECTED':\n\t          car = action.cable.car;\n\t          break;\n\t        default:\n\t          break;\n\t      }\n\t\n\t      return newState;\n\t    };\n\t  };\n\t};\n\t\n\tmiddleware.connect = function (url, store) {\n\t  return new _cableCar2.default(url, store);\n\t};\n\t\n\texports.middleware = middleware;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _actioncable = __webpack_require__(4);\n\t\n\tvar _actioncable2 = _interopRequireDefault(_actioncable);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar CableCar = function () {\n\t  function CableCar(url, store) {\n\t    _classCallCheck(this, CableCar);\n\t\n\t    this.store = store;\n\t    _actioncable2.default.startDebugging();\n\t    this.consumer = _actioncable2.default.createConsumer(url);\n\t    this.store.dispatch({ type: 'CABLE_CONNECTED', cable: { car: this } });\n\t  }\n\t\n\t  _createClass(CableCar, [{\n\t    key: 'dispatch',\n\t    value: function dispatch(type, cable) {\n\t      var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t      var action = {\n\t        type: 'CABLE_' + type,\n\t        cable: cable,\n\t        payload: payload\n\t      };\n\t      this.store.dispatch(action);\n\t    }\n\t  }, {\n\t    key: 'subscribe',\n\t    value: function subscribe(channel, params) {\n\t      var _this = this;\n\t\n\t      var options = _extends({ channel: channel }, params);\n\t      var prefix = channel.toUpperCase();\n\t      this.subscription = this.consumer.subscriptions.create(options, {\n\t        initialized: function initialized() {\n\t          return _this.dispatch(prefix + '_INITIALIZED', options);\n\t        },\n\t        connected: function connected() {\n\t          return _this.dispatch(prefix + '_CONNECTED', options);\n\t        },\n\t        disconnected: function disconnected() {\n\t          return _this.dispatch(prefix + '_DISCONNECTED', options);\n\t        },\n\t        received: function received(data) {\n\t          return _this.dispatch(prefix + '_RECEIVED', options, data);\n\t        },\n\t        rejected: function rejected() {\n\t          _this.dispatch(prefix + '_REJECTED', options);\n\t          throw new Error('ActionCable: Attempt to subscribe was rejected. (' + JSON.stringify(options) + ')');\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'send',\n\t    value: function send(channel, params, payload) {\n\t      var options = _extends({ channel: channel }, params);\n\t      var identifier = JSON.stringify(options);\n\t      var subscriptions = this.consumer.subscriptions.findAll(identifier);\n\t      subscriptions.map(function (item) {\n\t        return item.send(payload);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'unsubscribe',\n\t    value: function unsubscribe(channel, params) {\n\t      var options = _extends({ channel: channel }, params);\n\t      var identifier = JSON.stringify(options);\n\t      var subscriptions = this.consumer.subscriptions.findAll(identifier);\n\t      subscriptions.map(function (x) {\n\t        return x.unsubscribe();\n\t      });\n\t    }\n\t  }, {\n\t    key: 'disconnect',\n\t    value: function disconnect() {\n\t      this.consumer.disconnect();\n\t      this.store.dispatch({ type: 'CABLE_DISCONNECTED' });\n\t    }\n\t  }]);\n\t\n\t  return CableCar;\n\t}();\n\t\n\texports.default = CableCar;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n\t  (function() {\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      this.ActionCable = {\n\t        INTERNAL: {\n\t          \"message_types\": {\n\t            \"welcome\": \"welcome\",\n\t            \"ping\": \"ping\",\n\t            \"confirmation\": \"confirm_subscription\",\n\t            \"rejection\": \"reject_subscription\"\n\t          },\n\t          \"default_mount_path\": \"/cable\",\n\t          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n\t        },\n\t        createConsumer: function(url) {\n\t          var ref;\n\t          if (url == null) {\n\t            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n\t          }\n\t          return new ActionCable.Consumer(this.createWebSocketURL(url));\n\t        },\n\t        getConfig: function(name) {\n\t          var element;\n\t          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n\t          return element != null ? element.getAttribute(\"content\") : void 0;\n\t        },\n\t        createWebSocketURL: function(url) {\n\t          var a;\n\t          if (url && !/^wss?:/i.test(url)) {\n\t            a = document.createElement(\"a\");\n\t            a.href = url;\n\t            a.href = a.href;\n\t            a.protocol = a.protocol.replace(\"http\", \"ws\");\n\t            return a.href;\n\t          } else {\n\t            return url;\n\t          }\n\t        },\n\t        startDebugging: function() {\n\t          return this.debugging = true;\n\t        },\n\t        stopDebugging: function() {\n\t          return this.debugging = null;\n\t        },\n\t        log: function() {\n\t          var messages;\n\t          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          if (this.debugging) {\n\t            messages.push(Date.now());\n\t            return console.log.apply(console, [\"[ActionCable]\"].concat(slice.call(messages)));\n\t          }\n\t        }\n\t      };\n\t\n\t    }).call(this);\n\t  }).call(this);\n\t\n\t  var ActionCable = this.ActionCable;\n\t\n\t  (function() {\n\t    (function() {\n\t      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\t\n\t      ActionCable.ConnectionMonitor = (function() {\n\t        var clamp, now, secondsSince;\n\t\n\t        ConnectionMonitor.pollInterval = {\n\t          min: 3,\n\t          max: 30\n\t        };\n\t\n\t        ConnectionMonitor.staleThreshold = 6;\n\t\n\t        function ConnectionMonitor(connection) {\n\t          this.connection = connection;\n\t          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n\t          this.reconnectAttempts = 0;\n\t        }\n\t\n\t        ConnectionMonitor.prototype.start = function() {\n\t          if (!this.isRunning()) {\n\t            this.startedAt = now();\n\t            delete this.stoppedAt;\n\t            this.startPolling();\n\t            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stop = function() {\n\t          if (this.isRunning()) {\n\t            this.stoppedAt = now();\n\t            this.stopPolling();\n\t            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n\t            return ActionCable.log(\"ConnectionMonitor stopped\");\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.isRunning = function() {\n\t          return (this.startedAt != null) && (this.stoppedAt == null);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordPing = function() {\n\t          return this.pingedAt = now();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordConnect = function() {\n\t          this.reconnectAttempts = 0;\n\t          this.recordPing();\n\t          delete this.disconnectedAt;\n\t          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.recordDisconnect = function() {\n\t          this.disconnectedAt = now();\n\t          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n\t        };\n\t\n\t        ConnectionMonitor.prototype.startPolling = function() {\n\t          this.stopPolling();\n\t          return this.poll();\n\t        };\n\t\n\t        ConnectionMonitor.prototype.stopPolling = function() {\n\t          return clearTimeout(this.pollTimeout);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.poll = function() {\n\t          return this.pollTimeout = setTimeout((function(_this) {\n\t            return function() {\n\t              _this.reconnectIfStale();\n\t              return _this.poll();\n\t            };\n\t          })(this), this.getPollInterval());\n\t        };\n\t\n\t        ConnectionMonitor.prototype.getPollInterval = function() {\n\t          var interval, max, min, ref;\n\t          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n\t          interval = 5 * Math.log(this.reconnectAttempts + 1);\n\t          return Math.round(clamp(interval, min, max) * 1000);\n\t        };\n\t\n\t        ConnectionMonitor.prototype.reconnectIfStale = function() {\n\t          if (this.connectionIsStale()) {\n\t            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n\t            this.reconnectAttempts++;\n\t            if (this.disconnectedRecently()) {\n\t              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n\t            } else {\n\t              ActionCable.log(\"ConnectionMonitor reopening\");\n\t              return this.connection.reopen();\n\t            }\n\t          }\n\t        };\n\t\n\t        ConnectionMonitor.prototype.connectionIsStale = function() {\n\t          var ref;\n\t          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.disconnectedRecently = function() {\n\t          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n\t        };\n\t\n\t        ConnectionMonitor.prototype.visibilityDidChange = function() {\n\t          if (document.visibilityState === \"visible\") {\n\t            return setTimeout((function(_this) {\n\t              return function() {\n\t                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n\t                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n\t                  return _this.connection.reopen();\n\t                }\n\t              };\n\t            })(this), 200);\n\t          }\n\t        };\n\t\n\t        now = function() {\n\t          return new Date().getTime();\n\t        };\n\t\n\t        secondsSince = function(time) {\n\t          return (now() - time) / 1000;\n\t        };\n\t\n\t        clamp = function(number, min, max) {\n\t          return Math.max(min, Math.min(max, number));\n\t        };\n\t\n\t        return ConnectionMonitor;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n\t        slice = [].slice,\n\t        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\t\n\t      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\t\n\t      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\t\n\t      ActionCable.Connection = (function() {\n\t        Connection.reopenDelay = 500;\n\t\n\t        function Connection(consumer) {\n\t          this.consumer = consumer;\n\t          this.open = bind(this.open, this);\n\t          this.subscriptions = this.consumer.subscriptions;\n\t          this.monitor = new ActionCable.ConnectionMonitor(this);\n\t          this.disconnected = true;\n\t        }\n\t\n\t        Connection.prototype.send = function(data) {\n\t          if (this.isOpen()) {\n\t            this.webSocket.send(JSON.stringify(data));\n\t            return true;\n\t          } else {\n\t            return false;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.open = function() {\n\t          if (this.isActive()) {\n\t            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n\t            throw new Error(\"Existing connection must be closed before opening\");\n\t          } else {\n\t            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n\t            if (this.webSocket != null) {\n\t              this.uninstallEventHandlers();\n\t            }\n\t            this.webSocket = new WebSocket(this.consumer.url, protocols);\n\t            this.installEventHandlers();\n\t            this.monitor.start();\n\t            return true;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.close = function(arg) {\n\t          var allowReconnect, ref1;\n\t          allowReconnect = (arg != null ? arg : {\n\t            allowReconnect: true\n\t          }).allowReconnect;\n\t          if (!allowReconnect) {\n\t            this.monitor.stop();\n\t          }\n\t          if (this.isActive()) {\n\t            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.reopen = function() {\n\t          var error, error1;\n\t          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n\t          if (this.isActive()) {\n\t            try {\n\t              return this.close();\n\t            } catch (error1) {\n\t              error = error1;\n\t              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n\t            } finally {\n\t              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n\t              setTimeout(this.open, this.constructor.reopenDelay);\n\t            }\n\t          } else {\n\t            return this.open();\n\t          }\n\t        };\n\t\n\t        Connection.prototype.getProtocol = function() {\n\t          var ref1;\n\t          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n\t        };\n\t\n\t        Connection.prototype.isOpen = function() {\n\t          return this.isState(\"open\");\n\t        };\n\t\n\t        Connection.prototype.isActive = function() {\n\t          return this.isState(\"open\", \"connecting\");\n\t        };\n\t\n\t        Connection.prototype.isProtocolSupported = function() {\n\t          var ref1;\n\t          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.isState = function() {\n\t          var ref1, states;\n\t          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n\t        };\n\t\n\t        Connection.prototype.getState = function() {\n\t          var ref1, state, value;\n\t          for (state in WebSocket) {\n\t            value = WebSocket[state];\n\t            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n\t              return state.toLowerCase();\n\t            }\n\t          }\n\t          return null;\n\t        };\n\t\n\t        Connection.prototype.installEventHandlers = function() {\n\t          var eventName, handler;\n\t          for (eventName in this.events) {\n\t            handler = this.events[eventName].bind(this);\n\t            this.webSocket[\"on\" + eventName] = handler;\n\t          }\n\t        };\n\t\n\t        Connection.prototype.uninstallEventHandlers = function() {\n\t          var eventName;\n\t          for (eventName in this.events) {\n\t            this.webSocket[\"on\" + eventName] = function() {};\n\t          }\n\t        };\n\t\n\t        Connection.prototype.events = {\n\t          message: function(event) {\n\t            var identifier, message, ref1, type;\n\t            if (!this.isProtocolSupported()) {\n\t              return;\n\t            }\n\t            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n\t            switch (type) {\n\t              case message_types.welcome:\n\t                this.monitor.recordConnect();\n\t                return this.subscriptions.reload();\n\t              case message_types.ping:\n\t                return this.monitor.recordPing();\n\t              case message_types.confirmation:\n\t                return this.subscriptions.notify(identifier, \"connected\");\n\t              case message_types.rejection:\n\t                return this.subscriptions.reject(identifier);\n\t              default:\n\t                return this.subscriptions.notify(identifier, \"received\", message);\n\t            }\n\t          },\n\t          open: function() {\n\t            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n\t            this.disconnected = false;\n\t            if (!this.isProtocolSupported()) {\n\t              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n\t              return this.close({\n\t                allowReconnect: false\n\t              });\n\t            }\n\t          },\n\t          close: function(event) {\n\t            ActionCable.log(\"WebSocket onclose event\");\n\t            if (this.disconnected) {\n\t              return;\n\t            }\n\t            this.disconnected = true;\n\t            this.monitor.recordDisconnect();\n\t            return this.subscriptions.notifyAll(\"disconnected\", {\n\t              willAttemptReconnect: this.monitor.isRunning()\n\t            });\n\t          },\n\t          error: function() {\n\t            return ActionCable.log(\"WebSocket onerror event\");\n\t          }\n\t        };\n\t\n\t        return Connection;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      var slice = [].slice;\n\t\n\t      ActionCable.Subscriptions = (function() {\n\t        function Subscriptions(consumer) {\n\t          this.consumer = consumer;\n\t          this.subscriptions = [];\n\t        }\n\t\n\t        Subscriptions.prototype.create = function(channelName, mixin) {\n\t          var channel, params, subscription;\n\t          channel = channelName;\n\t          params = typeof channel === \"object\" ? channel : {\n\t            channel: channel\n\t          };\n\t          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n\t          return this.add(subscription);\n\t        };\n\t\n\t        Subscriptions.prototype.add = function(subscription) {\n\t          this.subscriptions.push(subscription);\n\t          this.consumer.ensureActiveConnection();\n\t          this.notify(subscription, \"initialized\");\n\t          this.sendCommand(subscription, \"subscribe\");\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.remove = function(subscription) {\n\t          this.forget(subscription);\n\t          if (!this.findAll(subscription.identifier).length) {\n\t            this.sendCommand(subscription, \"unsubscribe\");\n\t          }\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.reject = function(identifier) {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.findAll(identifier);\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            this.forget(subscription);\n\t            this.notify(subscription, \"rejected\");\n\t            results.push(subscription);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.forget = function(subscription) {\n\t          var s;\n\t          this.subscriptions = (function() {\n\t            var i, len, ref, results;\n\t            ref = this.subscriptions;\n\t            results = [];\n\t            for (i = 0, len = ref.length; i < len; i++) {\n\t              s = ref[i];\n\t              if (s !== subscription) {\n\t                results.push(s);\n\t              }\n\t            }\n\t            return results;\n\t          }).call(this);\n\t          return subscription;\n\t        };\n\t\n\t        Subscriptions.prototype.findAll = function(identifier) {\n\t          var i, len, ref, results, s;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            s = ref[i];\n\t            if (s.identifier === identifier) {\n\t              results.push(s);\n\t            }\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.reload = function() {\n\t          var i, len, ref, results, subscription;\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.sendCommand(subscription, \"subscribe\"));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notifyAll = function() {\n\t          var args, callbackName, i, len, ref, results, subscription;\n\t          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n\t          ref = this.subscriptions;\n\t          results = [];\n\t          for (i = 0, len = ref.length; i < len; i++) {\n\t            subscription = ref[i];\n\t            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.notify = function() {\n\t          var args, callbackName, i, len, results, subscription, subscriptions;\n\t          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n\t          if (typeof subscription === \"string\") {\n\t            subscriptions = this.findAll(subscription);\n\t          } else {\n\t            subscriptions = [subscription];\n\t          }\n\t          results = [];\n\t          for (i = 0, len = subscriptions.length; i < len; i++) {\n\t            subscription = subscriptions[i];\n\t            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n\t          }\n\t          return results;\n\t        };\n\t\n\t        Subscriptions.prototype.sendCommand = function(subscription, command) {\n\t          var identifier;\n\t          identifier = subscription.identifier;\n\t          return this.consumer.send({\n\t            command: command,\n\t            identifier: identifier\n\t          });\n\t        };\n\t\n\t        return Subscriptions;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Subscription = (function() {\n\t        var extend;\n\t\n\t        function Subscription(consumer, params, mixin) {\n\t          this.consumer = consumer;\n\t          if (params == null) {\n\t            params = {};\n\t          }\n\t          this.identifier = JSON.stringify(params);\n\t          extend(this, mixin);\n\t        }\n\t\n\t        Subscription.prototype.perform = function(action, data) {\n\t          if (data == null) {\n\t            data = {};\n\t          }\n\t          data.action = action;\n\t          return this.send(data);\n\t        };\n\t\n\t        Subscription.prototype.send = function(data) {\n\t          return this.consumer.send({\n\t            command: \"message\",\n\t            identifier: this.identifier,\n\t            data: JSON.stringify(data)\n\t          });\n\t        };\n\t\n\t        Subscription.prototype.unsubscribe = function() {\n\t          return this.consumer.subscriptions.remove(this);\n\t        };\n\t\n\t        extend = function(object, properties) {\n\t          var key, value;\n\t          if (properties != null) {\n\t            for (key in properties) {\n\t              value = properties[key];\n\t              object[key] = value;\n\t            }\n\t          }\n\t          return object;\n\t        };\n\t\n\t        return Subscription;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t    (function() {\n\t      ActionCable.Consumer = (function() {\n\t        function Consumer(url) {\n\t          this.url = url;\n\t          this.subscriptions = new ActionCable.Subscriptions(this);\n\t          this.connection = new ActionCable.Connection(this);\n\t        }\n\t\n\t        Consumer.prototype.send = function(data) {\n\t          return this.connection.send(data);\n\t        };\n\t\n\t        Consumer.prototype.connect = function() {\n\t          return this.connection.open();\n\t        };\n\t\n\t        Consumer.prototype.disconnect = function() {\n\t          return this.connection.close({\n\t            allowReconnect: false\n\t          });\n\t        };\n\t\n\t        Consumer.prototype.ensureActiveConnection = function() {\n\t          if (!this.connection.isActive()) {\n\t            return this.connection.open();\n\t          }\n\t        };\n\t\n\t        return Consumer;\n\t\n\t      })();\n\t\n\t    }).call(this);\n\t  }).call(this);\n\t\n\t  if (typeof module === \"object\" && module.exports) {\n\t    module.exports = ActionCable;\n\t  } else if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ActionCable), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}).call(this);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// redux-cablecar.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e279517a6187629f3f44","export * from './actions';\nexport * from './middleware';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","export function cableConnect(url) {\n  return {\n    type: 'CABLE_CONNECT',\n    cable: { url }\n  };\n}\n\nexport function cableDisconnect() {\n  return {\n    type: 'CABLE_DISCONNECT',\n    cable: {}\n  };\n}\n\nexport function cableSubscribe(channel, params) {\n  return {\n    type: 'CABLE_SUBSCRIBE',\n    cable: { channel, params }\n  };\n}\n\nexport function cableUnsubscribe(channel, params) {\n  return {\n    type: 'CABLE_UNSUBSCRIBE',\n    cable: { channel, params }\n  };\n}\n\nexport function cableSend(channel, params, payload) {\n  return {\n    type: 'CABLE_SEND',\n    cable: { channel, params },\n    payload\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions.js","import CableCar from './cableCar';\n\nlet car;\n\nconst middleware = store => next => (action) => {\n\n  switch (action.type) {\n    case 'CABLE_CONNECT':\n      const { url } = action.cable;\n      new CableCar(url, store);\n      break;\n    case 'CABLE_SUBSCRIBE':\n      car.subscribe(action.cable.channel, action.cable.params);\n      break;\n    case 'CABLE_UNSUBSCRIBE':\n      car.unsubscribe(action.cable.channel, action.cable.params);\n      break;\n    case 'CABLE_DISCONNECT':\n      car.disconnect();\n      car = null;\n      break;\n    case 'CABLE_SEND':\n      car.send(action.cable.channel, action.cable.params, action.payload);\n    default:\n      break;\n  }\n\n  const newState = next(action);\n\n  switch (action.type) {\n    case 'CABLE_CONNECTED':\n      car = action.cable.car;\n      break;\n    default:\n      break;\n  }\n\n  return newState;\n};\n\nmiddleware.connect = (url, store) => new CableCar(url, store);\n\nexport { middleware };\n\n\n\n// WEBPACK FOOTER //\n// ./src/middleware.js","import ActionCable from 'actioncable';\n\nclass CableCar {\n\n  constructor(url, store) {\n    this.store = store;\n    ActionCable.startDebugging();\n    this.consumer = ActionCable.createConsumer(url);\n    this.store.dispatch({ type: 'CABLE_CONNECTED', cable: { car: this } });\n  }\n\n  dispatch(type, cable, payload = {}) {\n    const action = {\n      type: `CABLE_${type}`,\n      cable,\n      payload,\n    };\n    this.store.dispatch(action);\n  }\n\n  subscribe(channel, params) {\n    const options = { channel , ...params};\n    const prefix = channel.toUpperCase();\n    this.subscription = this.consumer.subscriptions.create(options, {\n      initialized:  () => this.dispatch(`${prefix}_INITIALIZED`, options),\n      connected:    () => this.dispatch(`${prefix}_CONNECTED`, options),\n      disconnected: () => this.dispatch(`${prefix}_DISCONNECTED`, options),\n      received: (data) => this.dispatch(`${prefix}_RECEIVED`, options, data),\n      rejected:     () => {\n        this.dispatch(`${prefix}_REJECTED`, options);\n        throw new Error(`ActionCable: Attempt to subscribe was rejected. (${JSON.stringify(options)})`);\n      }\n    });\n  }\n\n  send(channel, params, payload) {\n    const options = { channel, ...params };\n    const identifier = JSON.stringify(options);\n    const subscriptions = this.consumer.subscriptions.findAll(identifier);\n    subscriptions.map(item => item.send(payload));\n  }\n\n  unsubscribe(channel, params) {\n    const options = { channel, ...params };\n    const identifier = JSON.stringify(options);\n    const subscriptions = this.consumer.subscriptions.findAll(identifier);\n    subscriptions.map( x => x.unsubscribe());\n  }\n\n  disconnect() {\n    this.consumer.disconnect();\n    this.store.dispatch({ type: 'CABLE_DISCONNECTED' });\n  }\n}\n\nexport default CableCar;\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCar.js","(function() {\n  (function() {\n    (function() {\n      var slice = [].slice;\n\n      this.ActionCable = {\n        INTERNAL: {\n          \"message_types\": {\n            \"welcome\": \"welcome\",\n            \"ping\": \"ping\",\n            \"confirmation\": \"confirm_subscription\",\n            \"rejection\": \"reject_subscription\"\n          },\n          \"default_mount_path\": \"/cable\",\n          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n        },\n        createConsumer: function(url) {\n          var ref;\n          if (url == null) {\n            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n          }\n          return new ActionCable.Consumer(this.createWebSocketURL(url));\n        },\n        getConfig: function(name) {\n          var element;\n          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n          return element != null ? element.getAttribute(\"content\") : void 0;\n        },\n        createWebSocketURL: function(url) {\n          var a;\n          if (url && !/^wss?:/i.test(url)) {\n            a = document.createElement(\"a\");\n            a.href = url;\n            a.href = a.href;\n            a.protocol = a.protocol.replace(\"http\", \"ws\");\n            return a.href;\n          } else {\n            return url;\n          }\n        },\n        startDebugging: function() {\n          return this.debugging = true;\n        },\n        stopDebugging: function() {\n          return this.debugging = null;\n        },\n        log: function() {\n          var messages;\n          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this.debugging) {\n            messages.push(Date.now());\n            return console.log.apply(console, [\"[ActionCable]\"].concat(slice.call(messages)));\n          }\n        }\n      };\n\n    }).call(this);\n  }).call(this);\n\n  var ActionCable = this.ActionCable;\n\n  (function() {\n    (function() {\n      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n      ActionCable.ConnectionMonitor = (function() {\n        var clamp, now, secondsSince;\n\n        ConnectionMonitor.pollInterval = {\n          min: 3,\n          max: 30\n        };\n\n        ConnectionMonitor.staleThreshold = 6;\n\n        function ConnectionMonitor(connection) {\n          this.connection = connection;\n          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n          this.reconnectAttempts = 0;\n        }\n\n        ConnectionMonitor.prototype.start = function() {\n          if (!this.isRunning()) {\n            this.startedAt = now();\n            delete this.stoppedAt;\n            this.startPolling();\n            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n          }\n        };\n\n        ConnectionMonitor.prototype.stop = function() {\n          if (this.isRunning()) {\n            this.stoppedAt = now();\n            this.stopPolling();\n            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor stopped\");\n          }\n        };\n\n        ConnectionMonitor.prototype.isRunning = function() {\n          return (this.startedAt != null) && (this.stoppedAt == null);\n        };\n\n        ConnectionMonitor.prototype.recordPing = function() {\n          return this.pingedAt = now();\n        };\n\n        ConnectionMonitor.prototype.recordConnect = function() {\n          this.reconnectAttempts = 0;\n          this.recordPing();\n          delete this.disconnectedAt;\n          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n        };\n\n        ConnectionMonitor.prototype.recordDisconnect = function() {\n          this.disconnectedAt = now();\n          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n        };\n\n        ConnectionMonitor.prototype.startPolling = function() {\n          this.stopPolling();\n          return this.poll();\n        };\n\n        ConnectionMonitor.prototype.stopPolling = function() {\n          return clearTimeout(this.pollTimeout);\n        };\n\n        ConnectionMonitor.prototype.poll = function() {\n          return this.pollTimeout = setTimeout((function(_this) {\n            return function() {\n              _this.reconnectIfStale();\n              return _this.poll();\n            };\n          })(this), this.getPollInterval());\n        };\n\n        ConnectionMonitor.prototype.getPollInterval = function() {\n          var interval, max, min, ref;\n          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n          interval = 5 * Math.log(this.reconnectAttempts + 1);\n          return Math.round(clamp(interval, min, max) * 1000);\n        };\n\n        ConnectionMonitor.prototype.reconnectIfStale = function() {\n          if (this.connectionIsStale()) {\n            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n            this.reconnectAttempts++;\n            if (this.disconnectedRecently()) {\n              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n            } else {\n              ActionCable.log(\"ConnectionMonitor reopening\");\n              return this.connection.reopen();\n            }\n          }\n        };\n\n        ConnectionMonitor.prototype.connectionIsStale = function() {\n          var ref;\n          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.disconnectedRecently = function() {\n          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.visibilityDidChange = function() {\n          if (document.visibilityState === \"visible\") {\n            return setTimeout((function(_this) {\n              return function() {\n                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n                  return _this.connection.reopen();\n                }\n              };\n            })(this), 200);\n          }\n        };\n\n        now = function() {\n          return new Date().getTime();\n        };\n\n        secondsSince = function(time) {\n          return (now() - time) / 1000;\n        };\n\n        clamp = function(number, min, max) {\n          return Math.max(min, Math.min(max, number));\n        };\n\n        return ConnectionMonitor;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n        slice = [].slice,\n        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\n      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\n      ActionCable.Connection = (function() {\n        Connection.reopenDelay = 500;\n\n        function Connection(consumer) {\n          this.consumer = consumer;\n          this.open = bind(this.open, this);\n          this.subscriptions = this.consumer.subscriptions;\n          this.monitor = new ActionCable.ConnectionMonitor(this);\n          this.disconnected = true;\n        }\n\n        Connection.prototype.send = function(data) {\n          if (this.isOpen()) {\n            this.webSocket.send(JSON.stringify(data));\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        Connection.prototype.open = function() {\n          if (this.isActive()) {\n            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n            throw new Error(\"Existing connection must be closed before opening\");\n          } else {\n            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n            if (this.webSocket != null) {\n              this.uninstallEventHandlers();\n            }\n            this.webSocket = new WebSocket(this.consumer.url, protocols);\n            this.installEventHandlers();\n            this.monitor.start();\n            return true;\n          }\n        };\n\n        Connection.prototype.close = function(arg) {\n          var allowReconnect, ref1;\n          allowReconnect = (arg != null ? arg : {\n            allowReconnect: true\n          }).allowReconnect;\n          if (!allowReconnect) {\n            this.monitor.stop();\n          }\n          if (this.isActive()) {\n            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n          }\n        };\n\n        Connection.prototype.reopen = function() {\n          var error, error1;\n          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n          if (this.isActive()) {\n            try {\n              return this.close();\n            } catch (error1) {\n              error = error1;\n              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n            } finally {\n              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n              setTimeout(this.open, this.constructor.reopenDelay);\n            }\n          } else {\n            return this.open();\n          }\n        };\n\n        Connection.prototype.getProtocol = function() {\n          var ref1;\n          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n        };\n\n        Connection.prototype.isOpen = function() {\n          return this.isState(\"open\");\n        };\n\n        Connection.prototype.isActive = function() {\n          return this.isState(\"open\", \"connecting\");\n        };\n\n        Connection.prototype.isProtocolSupported = function() {\n          var ref1;\n          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n        };\n\n        Connection.prototype.isState = function() {\n          var ref1, states;\n          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n        };\n\n        Connection.prototype.getState = function() {\n          var ref1, state, value;\n          for (state in WebSocket) {\n            value = WebSocket[state];\n            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n              return state.toLowerCase();\n            }\n          }\n          return null;\n        };\n\n        Connection.prototype.installEventHandlers = function() {\n          var eventName, handler;\n          for (eventName in this.events) {\n            handler = this.events[eventName].bind(this);\n            this.webSocket[\"on\" + eventName] = handler;\n          }\n        };\n\n        Connection.prototype.uninstallEventHandlers = function() {\n          var eventName;\n          for (eventName in this.events) {\n            this.webSocket[\"on\" + eventName] = function() {};\n          }\n        };\n\n        Connection.prototype.events = {\n          message: function(event) {\n            var identifier, message, ref1, type;\n            if (!this.isProtocolSupported()) {\n              return;\n            }\n            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n            switch (type) {\n              case message_types.welcome:\n                this.monitor.recordConnect();\n                return this.subscriptions.reload();\n              case message_types.ping:\n                return this.monitor.recordPing();\n              case message_types.confirmation:\n                return this.subscriptions.notify(identifier, \"connected\");\n              case message_types.rejection:\n                return this.subscriptions.reject(identifier);\n              default:\n                return this.subscriptions.notify(identifier, \"received\", message);\n            }\n          },\n          open: function() {\n            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n            this.disconnected = false;\n            if (!this.isProtocolSupported()) {\n              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n              return this.close({\n                allowReconnect: false\n              });\n            }\n          },\n          close: function(event) {\n            ActionCable.log(\"WebSocket onclose event\");\n            if (this.disconnected) {\n              return;\n            }\n            this.disconnected = true;\n            this.monitor.recordDisconnect();\n            return this.subscriptions.notifyAll(\"disconnected\", {\n              willAttemptReconnect: this.monitor.isRunning()\n            });\n          },\n          error: function() {\n            return ActionCable.log(\"WebSocket onerror event\");\n          }\n        };\n\n        return Connection;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var slice = [].slice;\n\n      ActionCable.Subscriptions = (function() {\n        function Subscriptions(consumer) {\n          this.consumer = consumer;\n          this.subscriptions = [];\n        }\n\n        Subscriptions.prototype.create = function(channelName, mixin) {\n          var channel, params, subscription;\n          channel = channelName;\n          params = typeof channel === \"object\" ? channel : {\n            channel: channel\n          };\n          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n          return this.add(subscription);\n        };\n\n        Subscriptions.prototype.add = function(subscription) {\n          this.subscriptions.push(subscription);\n          this.consumer.ensureActiveConnection();\n          this.notify(subscription, \"initialized\");\n          this.sendCommand(subscription, \"subscribe\");\n          return subscription;\n        };\n\n        Subscriptions.prototype.remove = function(subscription) {\n          this.forget(subscription);\n          if (!this.findAll(subscription.identifier).length) {\n            this.sendCommand(subscription, \"unsubscribe\");\n          }\n          return subscription;\n        };\n\n        Subscriptions.prototype.reject = function(identifier) {\n          var i, len, ref, results, subscription;\n          ref = this.findAll(identifier);\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            this.forget(subscription);\n            this.notify(subscription, \"rejected\");\n            results.push(subscription);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.forget = function(subscription) {\n          var s;\n          this.subscriptions = (function() {\n            var i, len, ref, results;\n            ref = this.subscriptions;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              s = ref[i];\n              if (s !== subscription) {\n                results.push(s);\n              }\n            }\n            return results;\n          }).call(this);\n          return subscription;\n        };\n\n        Subscriptions.prototype.findAll = function(identifier) {\n          var i, len, ref, results, s;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            s = ref[i];\n            if (s.identifier === identifier) {\n              results.push(s);\n            }\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.reload = function() {\n          var i, len, ref, results, subscription;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.sendCommand(subscription, \"subscribe\"));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notifyAll = function() {\n          var args, callbackName, i, len, ref, results, subscription;\n          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notify = function() {\n          var args, callbackName, i, len, results, subscription, subscriptions;\n          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n          if (typeof subscription === \"string\") {\n            subscriptions = this.findAll(subscription);\n          } else {\n            subscriptions = [subscription];\n          }\n          results = [];\n          for (i = 0, len = subscriptions.length; i < len; i++) {\n            subscription = subscriptions[i];\n            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.sendCommand = function(subscription, command) {\n          var identifier;\n          identifier = subscription.identifier;\n          return this.consumer.send({\n            command: command,\n            identifier: identifier\n          });\n        };\n\n        return Subscriptions;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Subscription = (function() {\n        var extend;\n\n        function Subscription(consumer, params, mixin) {\n          this.consumer = consumer;\n          if (params == null) {\n            params = {};\n          }\n          this.identifier = JSON.stringify(params);\n          extend(this, mixin);\n        }\n\n        Subscription.prototype.perform = function(action, data) {\n          if (data == null) {\n            data = {};\n          }\n          data.action = action;\n          return this.send(data);\n        };\n\n        Subscription.prototype.send = function(data) {\n          return this.consumer.send({\n            command: \"message\",\n            identifier: this.identifier,\n            data: JSON.stringify(data)\n          });\n        };\n\n        Subscription.prototype.unsubscribe = function() {\n          return this.consumer.subscriptions.remove(this);\n        };\n\n        extend = function(object, properties) {\n          var key, value;\n          if (properties != null) {\n            for (key in properties) {\n              value = properties[key];\n              object[key] = value;\n            }\n          }\n          return object;\n        };\n\n        return Subscription;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Consumer = (function() {\n        function Consumer(url) {\n          this.url = url;\n          this.subscriptions = new ActionCable.Subscriptions(this);\n          this.connection = new ActionCable.Connection(this);\n        }\n\n        Consumer.prototype.send = function(data) {\n          return this.connection.send(data);\n        };\n\n        Consumer.prototype.connect = function() {\n          return this.connection.open();\n        };\n\n        Consumer.prototype.disconnect = function() {\n          return this.connection.close({\n            allowReconnect: false\n          });\n        };\n\n        Consumer.prototype.ensureActiveConnection = function() {\n          if (!this.connection.isActive()) {\n            return this.connection.open();\n          }\n        };\n\n        return Consumer;\n\n      })();\n\n    }).call(this);\n  }).call(this);\n\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = ActionCable;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(ActionCable);\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/actioncable/lib/assets/compiled/action_cable.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}