{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///bundle.min.js","webpack:///webpack/bootstrap a2683a9c98d8d398bd4a","webpack:///./src/actions.js","webpack:///./src/middleware.js","webpack:///./~/actioncable/lib/assets/compiled/action_cable.js","webpack:///./src/cableCar.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","connect","url","type","cable","disconnect","subscribe","channel","params","unsubscribe","send","payload","_cableCar","_cableCar2","obj","default","car","middleware","store","next","action","newState","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","slice","ActionCable","INTERNAL","message_types","welcome","ping","confirmation","rejection","default_mount_path","protocols","WebSocket","window","logger","console","createConsumer","ref","getConfig","Consumer","createWebSocketURL","element","document","head","querySelector","getAttribute","a","test","createElement","href","protocol","replace","startDebugging","debugging","stopDebugging","log","messages","arguments","length","push","Date","now","apply","concat","bind","fn","me","ConnectionMonitor","connection","visibilityDidChange","reconnectAttempts","clamp","secondsSince","pollInterval","min","max","staleThreshold","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","getPollInterval","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","_this","reconnectIfStale","interval","constructor","Math","round","connectionIsStale","disconnectedRecently","reopen","visibilityState","isOpen","getTime","time","number","supportedProtocols","indexOf","item","Connection","consumer","open","subscriptions","monitor","disconnected","reopenDelay","data","webSocket","JSON","stringify","isActive","getState","uninstallEventHandlers","installEventHandlers","close","arg","allowReconnect","ref1","error","error1","getProtocol","isState","isProtocolSupported","states","state","readyState","toLowerCase","eventName","handler","events","message","event","identifier","parse","reload","notify","reject","notifyAll","willAttemptReconnect","Subscriptions","create","channelName","mixin","subscription","Subscription","add","ensureActiveConnection","sendCommand","remove","forget","findAll","len","results","args","callbackName","command","extend","perform","properties","key","undefined","_classCallCheck","instance","Constructor","TypeError","_extends","assign","target","source","_createClass","defineProperties","props","descriptor","writable","protoProps","staticProps","_actioncable","_actioncable2","CableCar","dispatch","options","prefix","toUpperCase","initialized","connected","received","rejected","Error","map","x","actions","_actions","newObj","_middleware","_middleware2"],"mappings":"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","file":"bundle.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReduxCableCar\"] = factory();\n\telse\n\t\troot[\"ReduxCableCar\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReduxCableCar\"] = factory();\n\telse\n\t\troot[\"ReduxCableCar\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.connect=connect;exports.\n\n\n\n\n\n\ndisconnect=disconnect;exports.\n\n\n\n\n\n\nsubscribe=subscribe;exports.\n\n\n\n\n\n\nunsubscribe=unsubscribe;exports.\n\n\n\n\n\n\nsend=send;function connect(url){return{type:'CABLE_CONNECT',cable:{url:url}};}function disconnect(){return{type:'CABLE_DISCONNECT',cable:{}};}function subscribe(channel,params){return{type:'CABLE_SUBSCRIBE',cable:{channel:channel,params:params}};}function unsubscribe(channel,params){return{type:'CABLE_UNSUBSCRIBE',cable:{channel:channel,params:params}};}function send(channel,params,payload){\nreturn{\ntype:'CABLE_SEND',\ncable:{channel:channel,params:params},\npayload:payload};\n\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports,\"__esModule\",{value:true});var _cableCar=__webpack_require__(3);var _cableCar2=_interopRequireDefault(_cableCar);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}\n\nvar car=void 0;\n\nvar middleware=function middleware(store){return function(next){return function(action){\n\nswitch(action.type){\ncase'CABLE_CONNECT':var\nurl=action.cable.url;\nnew _cableCar2.default(url,store);\nbreak;\ncase'CABLE_SUBSCRIBE':\ncar.subscribe(action.cable.channel,action.cable.params);\nbreak;\ncase'CABLE_UNSUBSCRIBE':\ncar.unsubscribe(action.cable.channel,action.cable.params);\nbreak;\ncase'CABLE_DISCONNECT':\ncar.disconnect();\ncar=null;\nbreak;\ncase'CABLE_SEND':\ncar.send(action.cable.channel,action.cable.params,action.payload);\ndefault:\nbreak;}\n\n\nvar newState=next(action);\n\nswitch(action.type){\ncase'CABLE_CONNECTED':\ncar=action.cable.car;\nbreak;\ndefault:\nbreak;}\n\n\nreturn newState;\n};};};\n\nmiddleware.connect=function(url,store){return new _cableCar2.default(url,store);};exports.default=\n\nmiddleware;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function() {\n  (function() {\n    (function() {\n      var slice = [].slice;\n\n      this.ActionCable = {\n        INTERNAL: {\n          \"message_types\": {\n            \"welcome\": \"welcome\",\n            \"ping\": \"ping\",\n            \"confirmation\": \"confirm_subscription\",\n            \"rejection\": \"reject_subscription\"\n          },\n          \"default_mount_path\": \"/cable\",\n          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n        },\n        WebSocket: window.WebSocket,\n        logger: window.console,\n        createConsumer: function(url) {\n          var ref;\n          if (url == null) {\n            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n          }\n          return new ActionCable.Consumer(this.createWebSocketURL(url));\n        },\n        getConfig: function(name) {\n          var element;\n          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n          return element != null ? element.getAttribute(\"content\") : void 0;\n        },\n        createWebSocketURL: function(url) {\n          var a;\n          if (url && !/^wss?:/i.test(url)) {\n            a = document.createElement(\"a\");\n            a.href = url;\n            a.href = a.href;\n            a.protocol = a.protocol.replace(\"http\", \"ws\");\n            return a.href;\n          } else {\n            return url;\n          }\n        },\n        startDebugging: function() {\n          return this.debugging = true;\n        },\n        stopDebugging: function() {\n          return this.debugging = null;\n        },\n        log: function() {\n          var messages, ref;\n          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this.debugging) {\n            messages.push(Date.now());\n            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n          }\n        }\n      };\n\n    }).call(this);\n  }).call(this);\n\n  var ActionCable = this.ActionCable;\n\n  (function() {\n    (function() {\n      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n      ActionCable.ConnectionMonitor = (function() {\n        var clamp, now, secondsSince;\n\n        ConnectionMonitor.pollInterval = {\n          min: 3,\n          max: 30\n        };\n\n        ConnectionMonitor.staleThreshold = 6;\n\n        function ConnectionMonitor(connection) {\n          this.connection = connection;\n          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n          this.reconnectAttempts = 0;\n        }\n\n        ConnectionMonitor.prototype.start = function() {\n          if (!this.isRunning()) {\n            this.startedAt = now();\n            delete this.stoppedAt;\n            this.startPolling();\n            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n          }\n        };\n\n        ConnectionMonitor.prototype.stop = function() {\n          if (this.isRunning()) {\n            this.stoppedAt = now();\n            this.stopPolling();\n            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor stopped\");\n          }\n        };\n\n        ConnectionMonitor.prototype.isRunning = function() {\n          return (this.startedAt != null) && (this.stoppedAt == null);\n        };\n\n        ConnectionMonitor.prototype.recordPing = function() {\n          return this.pingedAt = now();\n        };\n\n        ConnectionMonitor.prototype.recordConnect = function() {\n          this.reconnectAttempts = 0;\n          this.recordPing();\n          delete this.disconnectedAt;\n          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n        };\n\n        ConnectionMonitor.prototype.recordDisconnect = function() {\n          this.disconnectedAt = now();\n          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n        };\n\n        ConnectionMonitor.prototype.startPolling = function() {\n          this.stopPolling();\n          return this.poll();\n        };\n\n        ConnectionMonitor.prototype.stopPolling = function() {\n          return clearTimeout(this.pollTimeout);\n        };\n\n        ConnectionMonitor.prototype.poll = function() {\n          return this.pollTimeout = setTimeout((function(_this) {\n            return function() {\n              _this.reconnectIfStale();\n              return _this.poll();\n            };\n          })(this), this.getPollInterval());\n        };\n\n        ConnectionMonitor.prototype.getPollInterval = function() {\n          var interval, max, min, ref;\n          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n          interval = 5 * Math.log(this.reconnectAttempts + 1);\n          return Math.round(clamp(interval, min, max) * 1000);\n        };\n\n        ConnectionMonitor.prototype.reconnectIfStale = function() {\n          if (this.connectionIsStale()) {\n            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n            this.reconnectAttempts++;\n            if (this.disconnectedRecently()) {\n              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n            } else {\n              ActionCable.log(\"ConnectionMonitor reopening\");\n              return this.connection.reopen();\n            }\n          }\n        };\n\n        ConnectionMonitor.prototype.connectionIsStale = function() {\n          var ref;\n          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.disconnectedRecently = function() {\n          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.visibilityDidChange = function() {\n          if (document.visibilityState === \"visible\") {\n            return setTimeout((function(_this) {\n              return function() {\n                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n                  return _this.connection.reopen();\n                }\n              };\n            })(this), 200);\n          }\n        };\n\n        now = function() {\n          return new Date().getTime();\n        };\n\n        secondsSince = function(time) {\n          return (now() - time) / 1000;\n        };\n\n        clamp = function(number, min, max) {\n          return Math.max(min, Math.min(max, number));\n        };\n\n        return ConnectionMonitor;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n        slice = [].slice,\n        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\n      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\n      ActionCable.Connection = (function() {\n        Connection.reopenDelay = 500;\n\n        function Connection(consumer) {\n          this.consumer = consumer;\n          this.open = bind(this.open, this);\n          this.subscriptions = this.consumer.subscriptions;\n          this.monitor = new ActionCable.ConnectionMonitor(this);\n          this.disconnected = true;\n        }\n\n        Connection.prototype.send = function(data) {\n          if (this.isOpen()) {\n            this.webSocket.send(JSON.stringify(data));\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        Connection.prototype.open = function() {\n          if (this.isActive()) {\n            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n            return false;\n          } else {\n            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n            if (this.webSocket != null) {\n              this.uninstallEventHandlers();\n            }\n            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n            this.installEventHandlers();\n            this.monitor.start();\n            return true;\n          }\n        };\n\n        Connection.prototype.close = function(arg) {\n          var allowReconnect, ref1;\n          allowReconnect = (arg != null ? arg : {\n            allowReconnect: true\n          }).allowReconnect;\n          if (!allowReconnect) {\n            this.monitor.stop();\n          }\n          if (this.isActive()) {\n            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n          }\n        };\n\n        Connection.prototype.reopen = function() {\n          var error;\n          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n          if (this.isActive()) {\n            try {\n              return this.close();\n            } catch (error1) {\n              error = error1;\n              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n            } finally {\n              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n              setTimeout(this.open, this.constructor.reopenDelay);\n            }\n          } else {\n            return this.open();\n          }\n        };\n\n        Connection.prototype.getProtocol = function() {\n          var ref1;\n          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n        };\n\n        Connection.prototype.isOpen = function() {\n          return this.isState(\"open\");\n        };\n\n        Connection.prototype.isActive = function() {\n          return this.isState(\"open\", \"connecting\");\n        };\n\n        Connection.prototype.isProtocolSupported = function() {\n          var ref1;\n          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n        };\n\n        Connection.prototype.isState = function() {\n          var ref1, states;\n          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n        };\n\n        Connection.prototype.getState = function() {\n          var ref1, state, value;\n          for (state in WebSocket) {\n            value = WebSocket[state];\n            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n              return state.toLowerCase();\n            }\n          }\n          return null;\n        };\n\n        Connection.prototype.installEventHandlers = function() {\n          var eventName, handler;\n          for (eventName in this.events) {\n            handler = this.events[eventName].bind(this);\n            this.webSocket[\"on\" + eventName] = handler;\n          }\n        };\n\n        Connection.prototype.uninstallEventHandlers = function() {\n          var eventName;\n          for (eventName in this.events) {\n            this.webSocket[\"on\" + eventName] = function() {};\n          }\n        };\n\n        Connection.prototype.events = {\n          message: function(event) {\n            var identifier, message, ref1, type;\n            if (!this.isProtocolSupported()) {\n              return;\n            }\n            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n            switch (type) {\n              case message_types.welcome:\n                this.monitor.recordConnect();\n                return this.subscriptions.reload();\n              case message_types.ping:\n                return this.monitor.recordPing();\n              case message_types.confirmation:\n                return this.subscriptions.notify(identifier, \"connected\");\n              case message_types.rejection:\n                return this.subscriptions.reject(identifier);\n              default:\n                return this.subscriptions.notify(identifier, \"received\", message);\n            }\n          },\n          open: function() {\n            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n            this.disconnected = false;\n            if (!this.isProtocolSupported()) {\n              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n              return this.close({\n                allowReconnect: false\n              });\n            }\n          },\n          close: function(event) {\n            ActionCable.log(\"WebSocket onclose event\");\n            if (this.disconnected) {\n              return;\n            }\n            this.disconnected = true;\n            this.monitor.recordDisconnect();\n            return this.subscriptions.notifyAll(\"disconnected\", {\n              willAttemptReconnect: this.monitor.isRunning()\n            });\n          },\n          error: function() {\n            return ActionCable.log(\"WebSocket onerror event\");\n          }\n        };\n\n        return Connection;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var slice = [].slice;\n\n      ActionCable.Subscriptions = (function() {\n        function Subscriptions(consumer) {\n          this.consumer = consumer;\n          this.subscriptions = [];\n        }\n\n        Subscriptions.prototype.create = function(channelName, mixin) {\n          var channel, params, subscription;\n          channel = channelName;\n          params = typeof channel === \"object\" ? channel : {\n            channel: channel\n          };\n          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n          return this.add(subscription);\n        };\n\n        Subscriptions.prototype.add = function(subscription) {\n          this.subscriptions.push(subscription);\n          this.consumer.ensureActiveConnection();\n          this.notify(subscription, \"initialized\");\n          this.sendCommand(subscription, \"subscribe\");\n          return subscription;\n        };\n\n        Subscriptions.prototype.remove = function(subscription) {\n          this.forget(subscription);\n          if (!this.findAll(subscription.identifier).length) {\n            this.sendCommand(subscription, \"unsubscribe\");\n          }\n          return subscription;\n        };\n\n        Subscriptions.prototype.reject = function(identifier) {\n          var i, len, ref, results, subscription;\n          ref = this.findAll(identifier);\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            this.forget(subscription);\n            this.notify(subscription, \"rejected\");\n            results.push(subscription);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.forget = function(subscription) {\n          var s;\n          this.subscriptions = (function() {\n            var i, len, ref, results;\n            ref = this.subscriptions;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              s = ref[i];\n              if (s !== subscription) {\n                results.push(s);\n              }\n            }\n            return results;\n          }).call(this);\n          return subscription;\n        };\n\n        Subscriptions.prototype.findAll = function(identifier) {\n          var i, len, ref, results, s;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            s = ref[i];\n            if (s.identifier === identifier) {\n              results.push(s);\n            }\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.reload = function() {\n          var i, len, ref, results, subscription;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.sendCommand(subscription, \"subscribe\"));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notifyAll = function() {\n          var args, callbackName, i, len, ref, results, subscription;\n          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notify = function() {\n          var args, callbackName, i, len, results, subscription, subscriptions;\n          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n          if (typeof subscription === \"string\") {\n            subscriptions = this.findAll(subscription);\n          } else {\n            subscriptions = [subscription];\n          }\n          results = [];\n          for (i = 0, len = subscriptions.length; i < len; i++) {\n            subscription = subscriptions[i];\n            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.sendCommand = function(subscription, command) {\n          var identifier;\n          identifier = subscription.identifier;\n          return this.consumer.send({\n            command: command,\n            identifier: identifier\n          });\n        };\n\n        return Subscriptions;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Subscription = (function() {\n        var extend;\n\n        function Subscription(consumer, params, mixin) {\n          this.consumer = consumer;\n          if (params == null) {\n            params = {};\n          }\n          this.identifier = JSON.stringify(params);\n          extend(this, mixin);\n        }\n\n        Subscription.prototype.perform = function(action, data) {\n          if (data == null) {\n            data = {};\n          }\n          data.action = action;\n          return this.send(data);\n        };\n\n        Subscription.prototype.send = function(data) {\n          return this.consumer.send({\n            command: \"message\",\n            identifier: this.identifier,\n            data: JSON.stringify(data)\n          });\n        };\n\n        Subscription.prototype.unsubscribe = function() {\n          return this.consumer.subscriptions.remove(this);\n        };\n\n        extend = function(object, properties) {\n          var key, value;\n          if (properties != null) {\n            for (key in properties) {\n              value = properties[key];\n              object[key] = value;\n            }\n          }\n          return object;\n        };\n\n        return Subscription;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Consumer = (function() {\n        function Consumer(url) {\n          this.url = url;\n          this.subscriptions = new ActionCable.Subscriptions(this);\n          this.connection = new ActionCable.Connection(this);\n        }\n\n        Consumer.prototype.send = function(data) {\n          return this.connection.send(data);\n        };\n\n        Consumer.prototype.connect = function() {\n          return this.connection.open();\n        };\n\n        Consumer.prototype.disconnect = function() {\n          return this.connection.close({\n            allowReconnect: false\n          });\n        };\n\n        Consumer.prototype.ensureActiveConnection = function() {\n          if (!this.connection.isActive()) {\n            return this.connection.open();\n          }\n        };\n\n        return Consumer;\n\n      })();\n\n    }).call(this);\n  }).call(this);\n\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = ActionCable;\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ActionCable),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}).call(this);\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports,\"__esModule\",{value:true});var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _actioncable=__webpack_require__(2);var _actioncable2=_interopRequireDefault(_actioncable);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}var\n\nCableCar=function(){\n\nfunction CableCar(url,store){_classCallCheck(this,CableCar);\nthis.store=store;\nthis.consumer=_actioncable2.default.createConsumer(url);\nthis.store.dispatch({type:'CABLE_CONNECTED',cable:{car:this}});\n}_createClass(CableCar,[{key:'dispatch',value:function dispatch(\n\ntype,cable){var payload=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};\nvar action={\ntype:'CABLE_'+type,\ncable:cable,\npayload:payload};\n\nthis.store.dispatch(action);\n}},{key:'subscribe',value:function subscribe(\n\nchannel,params){var _this=this;\nvar options=_extends({channel:channel},params);\nvar prefix=channel.toUpperCase();\nthis.subscription=this.consumer.subscriptions.create(options,{\ninitialized:function initialized(){return _this.dispatch(prefix+'_INITIALIZED',options);},\nconnected:function connected(){return _this.dispatch(prefix+'_CONNECTED',options);},\ndisconnected:function disconnected(){return _this.dispatch(prefix+'_DISCONNECTED',options);},\nreceived:function received(data){return _this.dispatch(prefix+'_RECEIVED',options,data);},\nrejected:function rejected(){\n_this.dispatch(prefix+'_REJECTED',options);\nthrow new Error('ActionCable: Attempt to subscribe was rejected. ('+JSON.stringify(options)+')');\n}});\n\n}},{key:'send',value:function send(\n\nchannel,params,payload){\nvar options=_extends({channel:channel},params);\nvar identifier=JSON.stringify(options);\nvar subscriptions=this.consumer.subscriptions.findAll(identifier);\nsubscriptions.map(function(item){return item.send(payload);});\n}},{key:'unsubscribe',value:function unsubscribe(\n\nchannel,params){\nvar options=_extends({channel:channel},params);\nvar identifier=JSON.stringify(options);\nvar subscriptions=this.consumer.subscriptions.findAll(identifier);\nsubscriptions.map(function(x){return x.unsubscribe();});\n}},{key:'disconnect',value:function disconnect()\n\n{\nthis.consumer.disconnect();\nthis.store.dispatch({type:'CABLE_DISCONNECTED'});\n}}]);return CableCar;}();exports.default=\n\n\nCableCar;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports,\"__esModule\",{value:true});exports.middleware=exports.actions=undefined;var _actions=__webpack_require__(0);var actions=_interopRequireWildcard(_actions);\nvar _middleware=__webpack_require__(1);var _middleware2=_interopRequireDefault(_middleware);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))newObj[key]=obj[key];}}newObj.default=obj;return newObj;}}exports.\n\nactions=actions;exports.middleware=_middleware2.default;exports.default=\n{actions:actions,middleware:_middleware2.default};\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// bundle.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a2683a9c98d8d398bd4a","export function connect(url) {\n  return {\n    type: 'CABLE_CONNECT',\n    cable: { url }\n  };\n}\n\nexport function disconnect() {\n  return {\n    type: 'CABLE_DISCONNECT',\n    cable: {}\n  };\n}\n\nexport function subscribe(channel, params) {\n  return {\n    type: 'CABLE_SUBSCRIBE',\n    cable: { channel, params }\n  };\n}\n\nexport function unsubscribe(channel, params) {\n  return {\n    type: 'CABLE_UNSUBSCRIBE',\n    cable: { channel, params }\n  };\n}\n\nexport function send(channel, params, payload) {\n  return {\n    type: 'CABLE_SEND',\n    cable: { channel, params },\n    payload\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/actions.js","import CableCar from './cableCar';\n\nlet car;\n\nconst middleware = store => next => (action) => {\n\n  switch (action.type) {\n    case 'CABLE_CONNECT':\n      const { url } = action.cable;\n      new CableCar(url, store);\n      break;\n    case 'CABLE_SUBSCRIBE':\n      car.subscribe(action.cable.channel, action.cable.params);\n      break;\n    case 'CABLE_UNSUBSCRIBE':\n      car.unsubscribe(action.cable.channel, action.cable.params);\n      break;\n    case 'CABLE_DISCONNECT':\n      car.disconnect();\n      car = null;\n      break;\n    case 'CABLE_SEND':\n      car.send(action.cable.channel, action.cable.params, action.payload);\n    default:\n      break;\n  }\n\n  const newState = next(action);\n\n  switch (action.type) {\n    case 'CABLE_CONNECTED':\n      car = action.cable.car;\n      break;\n    default:\n      break;\n  }\n\n  return newState;\n};\n\nmiddleware.connect = (url, store) => new CableCar(url, store);\n\nexport default middleware;\n\n\n\n// WEBPACK FOOTER //\n// ./src/middleware.js","(function() {\n  (function() {\n    (function() {\n      var slice = [].slice;\n\n      this.ActionCable = {\n        INTERNAL: {\n          \"message_types\": {\n            \"welcome\": \"welcome\",\n            \"ping\": \"ping\",\n            \"confirmation\": \"confirm_subscription\",\n            \"rejection\": \"reject_subscription\"\n          },\n          \"default_mount_path\": \"/cable\",\n          \"protocols\": [\"actioncable-v1-json\", \"actioncable-unsupported\"]\n        },\n        WebSocket: window.WebSocket,\n        logger: window.console,\n        createConsumer: function(url) {\n          var ref;\n          if (url == null) {\n            url = (ref = this.getConfig(\"url\")) != null ? ref : this.INTERNAL.default_mount_path;\n          }\n          return new ActionCable.Consumer(this.createWebSocketURL(url));\n        },\n        getConfig: function(name) {\n          var element;\n          element = document.head.querySelector(\"meta[name='action-cable-\" + name + \"']\");\n          return element != null ? element.getAttribute(\"content\") : void 0;\n        },\n        createWebSocketURL: function(url) {\n          var a;\n          if (url && !/^wss?:/i.test(url)) {\n            a = document.createElement(\"a\");\n            a.href = url;\n            a.href = a.href;\n            a.protocol = a.protocol.replace(\"http\", \"ws\");\n            return a.href;\n          } else {\n            return url;\n          }\n        },\n        startDebugging: function() {\n          return this.debugging = true;\n        },\n        stopDebugging: function() {\n          return this.debugging = null;\n        },\n        log: function() {\n          var messages, ref;\n          messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          if (this.debugging) {\n            messages.push(Date.now());\n            return (ref = this.logger).log.apply(ref, [\"[ActionCable]\"].concat(slice.call(messages)));\n          }\n        }\n      };\n\n    }).call(this);\n  }).call(this);\n\n  var ActionCable = this.ActionCable;\n\n  (function() {\n    (function() {\n      var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n      ActionCable.ConnectionMonitor = (function() {\n        var clamp, now, secondsSince;\n\n        ConnectionMonitor.pollInterval = {\n          min: 3,\n          max: 30\n        };\n\n        ConnectionMonitor.staleThreshold = 6;\n\n        function ConnectionMonitor(connection) {\n          this.connection = connection;\n          this.visibilityDidChange = bind(this.visibilityDidChange, this);\n          this.reconnectAttempts = 0;\n        }\n\n        ConnectionMonitor.prototype.start = function() {\n          if (!this.isRunning()) {\n            this.startedAt = now();\n            delete this.stoppedAt;\n            this.startPolling();\n            document.addEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor started. pollInterval = \" + (this.getPollInterval()) + \" ms\");\n          }\n        };\n\n        ConnectionMonitor.prototype.stop = function() {\n          if (this.isRunning()) {\n            this.stoppedAt = now();\n            this.stopPolling();\n            document.removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n            return ActionCable.log(\"ConnectionMonitor stopped\");\n          }\n        };\n\n        ConnectionMonitor.prototype.isRunning = function() {\n          return (this.startedAt != null) && (this.stoppedAt == null);\n        };\n\n        ConnectionMonitor.prototype.recordPing = function() {\n          return this.pingedAt = now();\n        };\n\n        ConnectionMonitor.prototype.recordConnect = function() {\n          this.reconnectAttempts = 0;\n          this.recordPing();\n          delete this.disconnectedAt;\n          return ActionCable.log(\"ConnectionMonitor recorded connect\");\n        };\n\n        ConnectionMonitor.prototype.recordDisconnect = function() {\n          this.disconnectedAt = now();\n          return ActionCable.log(\"ConnectionMonitor recorded disconnect\");\n        };\n\n        ConnectionMonitor.prototype.startPolling = function() {\n          this.stopPolling();\n          return this.poll();\n        };\n\n        ConnectionMonitor.prototype.stopPolling = function() {\n          return clearTimeout(this.pollTimeout);\n        };\n\n        ConnectionMonitor.prototype.poll = function() {\n          return this.pollTimeout = setTimeout((function(_this) {\n            return function() {\n              _this.reconnectIfStale();\n              return _this.poll();\n            };\n          })(this), this.getPollInterval());\n        };\n\n        ConnectionMonitor.prototype.getPollInterval = function() {\n          var interval, max, min, ref;\n          ref = this.constructor.pollInterval, min = ref.min, max = ref.max;\n          interval = 5 * Math.log(this.reconnectAttempts + 1);\n          return Math.round(clamp(interval, min, max) * 1000);\n        };\n\n        ConnectionMonitor.prototype.reconnectIfStale = function() {\n          if (this.connectionIsStale()) {\n            ActionCable.log(\"ConnectionMonitor detected stale connection. reconnectAttempts = \" + this.reconnectAttempts + \", pollInterval = \" + (this.getPollInterval()) + \" ms, time disconnected = \" + (secondsSince(this.disconnectedAt)) + \" s, stale threshold = \" + this.constructor.staleThreshold + \" s\");\n            this.reconnectAttempts++;\n            if (this.disconnectedRecently()) {\n              return ActionCable.log(\"ConnectionMonitor skipping reopening recent disconnect\");\n            } else {\n              ActionCable.log(\"ConnectionMonitor reopening\");\n              return this.connection.reopen();\n            }\n          }\n        };\n\n        ConnectionMonitor.prototype.connectionIsStale = function() {\n          var ref;\n          return secondsSince((ref = this.pingedAt) != null ? ref : this.startedAt) > this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.disconnectedRecently = function() {\n          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n        };\n\n        ConnectionMonitor.prototype.visibilityDidChange = function() {\n          if (document.visibilityState === \"visible\") {\n            return setTimeout((function(_this) {\n              return function() {\n                if (_this.connectionIsStale() || !_this.connection.isOpen()) {\n                  ActionCable.log(\"ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = \" + document.visibilityState);\n                  return _this.connection.reopen();\n                }\n              };\n            })(this), 200);\n          }\n        };\n\n        now = function() {\n          return new Date().getTime();\n        };\n\n        secondsSince = function(time) {\n          return (now() - time) / 1000;\n        };\n\n        clamp = function(number, min, max) {\n          return Math.max(min, Math.min(max, number));\n        };\n\n        return ConnectionMonitor;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var i, message_types, protocols, ref, supportedProtocols, unsupportedProtocol,\n        slice = [].slice,\n        bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n      ref = ActionCable.INTERNAL, message_types = ref.message_types, protocols = ref.protocols;\n\n      supportedProtocols = 2 <= protocols.length ? slice.call(protocols, 0, i = protocols.length - 1) : (i = 0, []), unsupportedProtocol = protocols[i++];\n\n      ActionCable.Connection = (function() {\n        Connection.reopenDelay = 500;\n\n        function Connection(consumer) {\n          this.consumer = consumer;\n          this.open = bind(this.open, this);\n          this.subscriptions = this.consumer.subscriptions;\n          this.monitor = new ActionCable.ConnectionMonitor(this);\n          this.disconnected = true;\n        }\n\n        Connection.prototype.send = function(data) {\n          if (this.isOpen()) {\n            this.webSocket.send(JSON.stringify(data));\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        Connection.prototype.open = function() {\n          if (this.isActive()) {\n            ActionCable.log(\"Attempted to open WebSocket, but existing socket is \" + (this.getState()));\n            return false;\n          } else {\n            ActionCable.log(\"Opening WebSocket, current state is \" + (this.getState()) + \", subprotocols: \" + protocols);\n            if (this.webSocket != null) {\n              this.uninstallEventHandlers();\n            }\n            this.webSocket = new ActionCable.WebSocket(this.consumer.url, protocols);\n            this.installEventHandlers();\n            this.monitor.start();\n            return true;\n          }\n        };\n\n        Connection.prototype.close = function(arg) {\n          var allowReconnect, ref1;\n          allowReconnect = (arg != null ? arg : {\n            allowReconnect: true\n          }).allowReconnect;\n          if (!allowReconnect) {\n            this.monitor.stop();\n          }\n          if (this.isActive()) {\n            return (ref1 = this.webSocket) != null ? ref1.close() : void 0;\n          }\n        };\n\n        Connection.prototype.reopen = function() {\n          var error;\n          ActionCable.log(\"Reopening WebSocket, current state is \" + (this.getState()));\n          if (this.isActive()) {\n            try {\n              return this.close();\n            } catch (error1) {\n              error = error1;\n              return ActionCable.log(\"Failed to reopen WebSocket\", error);\n            } finally {\n              ActionCable.log(\"Reopening WebSocket in \" + this.constructor.reopenDelay + \"ms\");\n              setTimeout(this.open, this.constructor.reopenDelay);\n            }\n          } else {\n            return this.open();\n          }\n        };\n\n        Connection.prototype.getProtocol = function() {\n          var ref1;\n          return (ref1 = this.webSocket) != null ? ref1.protocol : void 0;\n        };\n\n        Connection.prototype.isOpen = function() {\n          return this.isState(\"open\");\n        };\n\n        Connection.prototype.isActive = function() {\n          return this.isState(\"open\", \"connecting\");\n        };\n\n        Connection.prototype.isProtocolSupported = function() {\n          var ref1;\n          return ref1 = this.getProtocol(), indexOf.call(supportedProtocols, ref1) >= 0;\n        };\n\n        Connection.prototype.isState = function() {\n          var ref1, states;\n          states = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return ref1 = this.getState(), indexOf.call(states, ref1) >= 0;\n        };\n\n        Connection.prototype.getState = function() {\n          var ref1, state, value;\n          for (state in WebSocket) {\n            value = WebSocket[state];\n            if (value === ((ref1 = this.webSocket) != null ? ref1.readyState : void 0)) {\n              return state.toLowerCase();\n            }\n          }\n          return null;\n        };\n\n        Connection.prototype.installEventHandlers = function() {\n          var eventName, handler;\n          for (eventName in this.events) {\n            handler = this.events[eventName].bind(this);\n            this.webSocket[\"on\" + eventName] = handler;\n          }\n        };\n\n        Connection.prototype.uninstallEventHandlers = function() {\n          var eventName;\n          for (eventName in this.events) {\n            this.webSocket[\"on\" + eventName] = function() {};\n          }\n        };\n\n        Connection.prototype.events = {\n          message: function(event) {\n            var identifier, message, ref1, type;\n            if (!this.isProtocolSupported()) {\n              return;\n            }\n            ref1 = JSON.parse(event.data), identifier = ref1.identifier, message = ref1.message, type = ref1.type;\n            switch (type) {\n              case message_types.welcome:\n                this.monitor.recordConnect();\n                return this.subscriptions.reload();\n              case message_types.ping:\n                return this.monitor.recordPing();\n              case message_types.confirmation:\n                return this.subscriptions.notify(identifier, \"connected\");\n              case message_types.rejection:\n                return this.subscriptions.reject(identifier);\n              default:\n                return this.subscriptions.notify(identifier, \"received\", message);\n            }\n          },\n          open: function() {\n            ActionCable.log(\"WebSocket onopen event, using '\" + (this.getProtocol()) + \"' subprotocol\");\n            this.disconnected = false;\n            if (!this.isProtocolSupported()) {\n              ActionCable.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n              return this.close({\n                allowReconnect: false\n              });\n            }\n          },\n          close: function(event) {\n            ActionCable.log(\"WebSocket onclose event\");\n            if (this.disconnected) {\n              return;\n            }\n            this.disconnected = true;\n            this.monitor.recordDisconnect();\n            return this.subscriptions.notifyAll(\"disconnected\", {\n              willAttemptReconnect: this.monitor.isRunning()\n            });\n          },\n          error: function() {\n            return ActionCable.log(\"WebSocket onerror event\");\n          }\n        };\n\n        return Connection;\n\n      })();\n\n    }).call(this);\n    (function() {\n      var slice = [].slice;\n\n      ActionCable.Subscriptions = (function() {\n        function Subscriptions(consumer) {\n          this.consumer = consumer;\n          this.subscriptions = [];\n        }\n\n        Subscriptions.prototype.create = function(channelName, mixin) {\n          var channel, params, subscription;\n          channel = channelName;\n          params = typeof channel === \"object\" ? channel : {\n            channel: channel\n          };\n          subscription = new ActionCable.Subscription(this.consumer, params, mixin);\n          return this.add(subscription);\n        };\n\n        Subscriptions.prototype.add = function(subscription) {\n          this.subscriptions.push(subscription);\n          this.consumer.ensureActiveConnection();\n          this.notify(subscription, \"initialized\");\n          this.sendCommand(subscription, \"subscribe\");\n          return subscription;\n        };\n\n        Subscriptions.prototype.remove = function(subscription) {\n          this.forget(subscription);\n          if (!this.findAll(subscription.identifier).length) {\n            this.sendCommand(subscription, \"unsubscribe\");\n          }\n          return subscription;\n        };\n\n        Subscriptions.prototype.reject = function(identifier) {\n          var i, len, ref, results, subscription;\n          ref = this.findAll(identifier);\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            this.forget(subscription);\n            this.notify(subscription, \"rejected\");\n            results.push(subscription);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.forget = function(subscription) {\n          var s;\n          this.subscriptions = (function() {\n            var i, len, ref, results;\n            ref = this.subscriptions;\n            results = [];\n            for (i = 0, len = ref.length; i < len; i++) {\n              s = ref[i];\n              if (s !== subscription) {\n                results.push(s);\n              }\n            }\n            return results;\n          }).call(this);\n          return subscription;\n        };\n\n        Subscriptions.prototype.findAll = function(identifier) {\n          var i, len, ref, results, s;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            s = ref[i];\n            if (s.identifier === identifier) {\n              results.push(s);\n            }\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.reload = function() {\n          var i, len, ref, results, subscription;\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.sendCommand(subscription, \"subscribe\"));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notifyAll = function() {\n          var args, callbackName, i, len, ref, results, subscription;\n          callbackName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n          ref = this.subscriptions;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            subscription = ref[i];\n            results.push(this.notify.apply(this, [subscription, callbackName].concat(slice.call(args))));\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.notify = function() {\n          var args, callbackName, i, len, results, subscription, subscriptions;\n          subscription = arguments[0], callbackName = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n          if (typeof subscription === \"string\") {\n            subscriptions = this.findAll(subscription);\n          } else {\n            subscriptions = [subscription];\n          }\n          results = [];\n          for (i = 0, len = subscriptions.length; i < len; i++) {\n            subscription = subscriptions[i];\n            results.push(typeof subscription[callbackName] === \"function\" ? subscription[callbackName].apply(subscription, args) : void 0);\n          }\n          return results;\n        };\n\n        Subscriptions.prototype.sendCommand = function(subscription, command) {\n          var identifier;\n          identifier = subscription.identifier;\n          return this.consumer.send({\n            command: command,\n            identifier: identifier\n          });\n        };\n\n        return Subscriptions;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Subscription = (function() {\n        var extend;\n\n        function Subscription(consumer, params, mixin) {\n          this.consumer = consumer;\n          if (params == null) {\n            params = {};\n          }\n          this.identifier = JSON.stringify(params);\n          extend(this, mixin);\n        }\n\n        Subscription.prototype.perform = function(action, data) {\n          if (data == null) {\n            data = {};\n          }\n          data.action = action;\n          return this.send(data);\n        };\n\n        Subscription.prototype.send = function(data) {\n          return this.consumer.send({\n            command: \"message\",\n            identifier: this.identifier,\n            data: JSON.stringify(data)\n          });\n        };\n\n        Subscription.prototype.unsubscribe = function() {\n          return this.consumer.subscriptions.remove(this);\n        };\n\n        extend = function(object, properties) {\n          var key, value;\n          if (properties != null) {\n            for (key in properties) {\n              value = properties[key];\n              object[key] = value;\n            }\n          }\n          return object;\n        };\n\n        return Subscription;\n\n      })();\n\n    }).call(this);\n    (function() {\n      ActionCable.Consumer = (function() {\n        function Consumer(url) {\n          this.url = url;\n          this.subscriptions = new ActionCable.Subscriptions(this);\n          this.connection = new ActionCable.Connection(this);\n        }\n\n        Consumer.prototype.send = function(data) {\n          return this.connection.send(data);\n        };\n\n        Consumer.prototype.connect = function() {\n          return this.connection.open();\n        };\n\n        Consumer.prototype.disconnect = function() {\n          return this.connection.close({\n            allowReconnect: false\n          });\n        };\n\n        Consumer.prototype.ensureActiveConnection = function() {\n          if (!this.connection.isActive()) {\n            return this.connection.open();\n          }\n        };\n\n        return Consumer;\n\n      })();\n\n    }).call(this);\n  }).call(this);\n\n  if (typeof module === \"object\" && module.exports) {\n    module.exports = ActionCable;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(ActionCable);\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/actioncable/lib/assets/compiled/action_cable.js\n// module id = 2\n// module chunks = 0","import ActionCable from 'actioncable';\n\nclass CableCar {\n\n  constructor(url, store) {\n    this.store = store;\n    this.consumer = ActionCable.createConsumer(url);\n    this.store.dispatch({ type: 'CABLE_CONNECTED', cable: { car: this } });\n  }\n\n  dispatch(type, cable, payload = {}) {\n    const action = {\n      type: `CABLE_${type}`,\n      cable,\n      payload,\n    };\n    this.store.dispatch(action);\n  }\n\n  subscribe(channel, params) {\n    const options = { channel , ...params};\n    const prefix = channel.toUpperCase();\n    this.subscription = this.consumer.subscriptions.create(options, {\n      initialized:  () => this.dispatch(`${prefix}_INITIALIZED`, options),\n      connected:    () => this.dispatch(`${prefix}_CONNECTED`, options),\n      disconnected: () => this.dispatch(`${prefix}_DISCONNECTED`, options),\n      received: (data) => this.dispatch(`${prefix}_RECEIVED`, options, data),\n      rejected:     () => {\n        this.dispatch(`${prefix}_REJECTED`, options);\n        throw new Error(`ActionCable: Attempt to subscribe was rejected. (${JSON.stringify(options)})`);\n      }\n    });\n  }\n\n  send(channel, params, payload) {\n    const options = { channel, ...params };\n    const identifier = JSON.stringify(options);\n    const subscriptions = this.consumer.subscriptions.findAll(identifier);\n    subscriptions.map(item => item.send(payload));\n  }\n\n  unsubscribe(channel, params) {\n    const options = { channel, ...params };\n    const identifier = JSON.stringify(options);\n    const subscriptions = this.consumer.subscriptions.findAll(identifier);\n    subscriptions.map( x => x.unsubscribe());\n  }\n\n  disconnect() {\n    this.consumer.disconnect();\n    this.store.dispatch({ type: 'CABLE_DISCONNECTED' });\n  }\n}\n\nexport default CableCar;\n\n\n\n// WEBPACK FOOTER //\n// ./src/cableCar.js","import * as actions from './actions';\nimport middleware from './middleware';\n\nexport { actions, middleware };\nexport default { actions, middleware };\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}